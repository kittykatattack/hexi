{"version":3,"sources":["../src/tileBasedLineOfSight.js"],"names":[],"mappings":"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","file":"tileBasedLineOfSight.js","sourcesContent":["let thingsToLoad = [\n  \"images/monsterMaze.png\",\n  \"maps/monsterMaze.json\"\n];\n\n//Create a new Hexi instance, and start it.\nlet g = hexi(704, 512, setup, thingsToLoad);\n\n//Set the background color and scale the canvas\n//g.backgroundColor = \"black\";\ng.scaleToWindow();\n\n//Start Hexi\ng.start();\n\n//Game variables\nlet world, alien, message, wallMapArray, monsterFrames,\n  bombMapArray, bombSprites, bombLayer, monsters,\n  leftArrow, upArrow, downArrow, rightArrow;\n\n//The `setup` function to initialize your application\nfunction setup() {\n\n  //Make the world from the Tiled JSON data and the tileset PNG image\n  world = g.makeTiledWorld(\n    \"maps/monsterMaze.json\",\n    \"images/monsterMaze.png\"\n  );\n\n  //Create the alien sprite and set its speed\n  alien = world.getObject(\"alien\");\n  alien.speed = 4\n\n  //Get a reference to the array that stores all the wall data\n  wallMapArray = world.getObject(\"wallLayer\").data;\n\n  //We're just using the monsters sprites in the Tiled Editor\n  //map as generic placeholders.  We're going to use their size and\n  //position data to build new monster sprites from scratch and place\n  //them in the world. That's because we want to give the monsters\n  //custom animation frames. Here's how to do this:\n\n  //1. Get a reference to the map's monster sprites and the \n  //layer container that those sprites are one\n  let mapMonsters = world.getObjects(\"monster\");\n  let monsterLayer = world.getObject(\"monsterLayer\");\n\n  //2.Define the monster's animation frames. In this example there are just\n  //two: the monster mouth open, and the monster's mouth closed.\n  monsterFrames = g.frames(\n    \"images/monsterMaze.png\", //The tileset image\n    [\n      [128, 0],\n      [128, 64]\n    ], //The `x` and `y` positions of frames\n    64, 64 //The `width` and `height` of each frame\n  );\n\n  //3.Create a new array called `monsters` that contains a new `monster`\n  //sprite for each `mapMonster` in the original array. The new\n  //`monster` sprites are created using the `monsterFrames` we defined\n  //above and have the same `x` and `y` positions as the original\n  //placeholder monsters from the Tiled Editor map. We're also going\n  //to give them new `direction` and `speed`. Finally, we need to make the \n  //placeholder monsters invisible and add the new `monster` sprite\n  //to the `monsterLayer` container. \n  monsters = mapMonsters.map(mapMonster => {\n    let monster = g.sprite(monsterFrames);\n    monster.x = mapMonster.x;\n    monster.y = mapMonster.y;\n    monster.direction = \"none\";\n    monster.speed = 4;\n    monsterLayer.addChild(monster);\n    mapMonster.visible = false;\n\n    //Define the monster's two states: `normal` and `angry`\n    //`0` and `1` refer to the monster's two animation frames\n    monster.states = {\n      normal: 0,\n      angry: 1\n    };\n    return monster;\n  });\n\n  //Give the `alien` a `direction` property and initilize it to \"none\"\n  alien.direction = \"none\";\n\n  //Configure Hexi's built in arrow keys to assign the alien a direction\n  //Create some keyboard objects\n  leftArrow = g.keyboard(37);\n  upArrow = g.keyboard(38);\n  rightArrow = g.keyboard(39);\n  downArrow = g.keyboard(40);\n\n  //Program the keyboard objects\n  leftArrow.press = () => alien.direction = \"left\";\n  upArrow.press = () => alien.direction = \"up\";\n  rightArrow.press = () => alien.direction = \"right\";\n  downArrow.press = () => alien.direction = \"down\";\n\n  //Change the game state to `play`\n  g.state = play;\n}\n\n//The `play` function contains all the game logic and runs in a loop\nfunction play() {\n\n  //Change the alien's direction if it's directly centered\n  //over a tile cell\n\n  if (isCenteredOverCell(alien)) {\n    let velocity = directionToVelocity(alien.direction, alien.speed);\n    alien.vx = velocity.vx;\n    alien.vy = velocity.vy;\n  }\n\n  //Move the alien\n  g.move(alien);\n\n  //Check for a collision between the alien and the floor\n  let alienVsFloor = g.hitTestTile(alien, wallMapArray, 0, world, \"every\");\n\n  //If every corner point on the alien isn't touching a floor \n  //tile (array gridIDNumber: 0) then prevent the alien from moving\n  if (!alienVsFloor.hit) {\n\n    //To prevent the alien from moving, subtract its velocity from its position\n    alien.x -= alien.vx;\n    alien.y -= alien.vy;\n    alien.vx = 0;\n    alien.vy = 0;\n  }\n\n  //Move he monsters\n  monsters.forEach(monster => {\n\n    //1. Is the monster directly centered over a map tile cell?\n    if (isCenteredOverCell(monster)) {\n\n      //2. Yes, it is, so find out which are valid directions to move.\n      //`findValidDirections` returns an array which can include any\n      //of these string values: \"up\", \"right\", \"down\", \"left\" or \"none\"\n      monster.validDirections = validDirections(\n        monster, wallMapArray, 0, world\n      );\n\n      //3. Check whether the monster has line of sight\n      monster.hasLineOfSight = tileBasedLineOfSight(\n        monster, //The first sprite\n        alien, //The second sprite\n        wallMapArray, //The tile map array\n        world, //The `world` object\n        0, //The Gid that represents and empty tile\n        16, //The distance between collision points\n        [90, -90, 0, 180, -180] //The angles to limit the line-of-sight\n      );\n\n      //4. Can the monster change its direction?\n      if (canChangeDirection(monster.validDirections)) {\n\n        //5. If it can, change the monster's direction to the closest direction\n        //if it has line of sight. If it doesn't have line of sight,\n        //choose a new random direction\n        if (monster.hasLineOfSight) {\n          monster.direction = closestDirection(monster, alien, monster.validDirections);\n        } else {\n          monster.direction = randomDirection(monster, monster.validDirections)\n        }\n      }\n\n      //6. Use the monster's direction and speed to find its new velocity\n      let velocity = directionToVelocity(monster.direction, monster.speed);\n      monster.vx = velocity.vx;\n      monster.vy = velocity.vy;\n    }\n\n    //7. Move the monster\n    monster.x += monster.vx;\n    monster.y += monster.vy;\n\n    //8. Optionally Change the monster's state.\n    //If the monster has line of sight,\n    //change the monster's state to `angry`. Otherwise, set its\n    //state to `normal`\n    if (monster.hasLineOfSight) {\n      monster.show(monster.states.angry);\n    } else {\n      monster.show(monster.states.normal);\n    }\n  });\n}\n\n//Helper functions\n\n//`isCenteredOverCell` returns true or false depending on whether a \n//sprite is exactly aligned to anintersection in the maze corridors\nfunction isCenteredOverCell(sprite) {\n  return Math.floor(sprite.x) % world.tilewidth === 0 && Math.floor(sprite.y) % world.tileheight === 0\n}\n\n//Convert the direction string to an object with `vx` and `vy`\n//velocity properties\nfunction directionToVelocity(direction = \"\", speed = 0) {\n  switch (direction) {\n    case \"up\":\n      return {\n        vy: -speed,\n        vx: 0\n      }\n      break;\n    case \"down\":\n      return {\n        vy: speed,\n        vx: 0\n      };\n      break;\n    case \"left\":\n      return {\n        vx: -speed,\n        vy: 0\n      };\n      break;\n    case \"right\":\n      return {\n        vx: speed,\n        vy: 0\n      };\n      break;\n    default:\n      return {\n        vx: 0,\n        vy: 0\n      };\n  }\n};\n\n//Change the sprite's velocity if it's centered \n//over a tile grid cell \nfunction changeDirection(sprite, direction, speed) {\n  switch (direction) {\n    case \"up\":\n      sprite.vy = -speed;\n      sprite.vx = 0;\n      break;\n    case \"down\":\n      sprite.vy = speed;\n      sprite.vx = 0;\n      break;\n    case \"left\":\n      sprite.vx = -speed;\n      sprite.vy = 0;\n      break;\n    case \"right\":\n      sprite.vx = speed;\n      sprite.vy = 0;\n      break;\n    default:\n      sprite.vx = 0;\n      sprite.vy = 0;\n      break;\n  }\n};\n\nfunction surroundingCrossCells(index, widthInTiles) {\n  return [\n    index - widthInTiles,\n    index - 1,\n    index + 1,\n    index + widthInTiles,\n  ];\n}\n\nfunction surroundingDiagonalCells(index, widthInTiles) {\n  return [\n    index - widthInTiles - 1,\n    index - widthInTiles + 1,\n    index + widthInTiles - 1,\n    index + widthInTiles + 1,\n  ];\n}\n\nfunction validDirections(sprite, mapArray, validGid, world) {\n\n  //Get the sprite's current map index position number\n  let index = g.getIndex(\n    sprite.x,\n    sprite.y,\n    world.tilewidth,\n    world.tileheight,\n    world.widthInTiles\n  );\n\n  //An array containing the index numbers of tile cells\n  //above, below and to the left and right of the sprite\n  let surroundingCrossCells = (index, widthInTiles) => {\n    return [\n      index - widthInTiles,\n      index - 1,\n      index + 1,\n      index + widthInTiles,\n    ];\n  };\n\n  //Get the index position numbers of the 4 cells to the top, right, left\n  //and bottom of the sprite\n  let surroundingIndexNumbers = surroundingCrossCells(index, world.widthInTiles);\n\n  //Find all the tile gid numbers that match the surrounding index numbers\n  let surroundingTileGids = surroundingIndexNumbers.map(index => mapArray[index]);\n\n  //`directionList` is an array of 4 string values that can be either\n  //\"up\", \"left\", \"right\", \"down\" or \"none\", depending on \n  //whether there is a cell with a valid gid that matches that direction.\n  let directionList = surroundingTileGids.map((gid, i) => {\n\n    //The possible directions\n    let possibleDirections = [\"up\", \"left\", \"right\", \"down\"];\n\n    //If the direction is valid, choose the matching string \n    //identifier for that direction. Otherwise, return \"none\"\n    if (gid === validGid) {\n      return possibleDirections[i];\n    } else {\n      return \"none\";\n    }\n  });\n\n  //We don't need \"none\" in the list of directions \n  //(it's just a placeholder), so let's filter it out\n  let filteredDirectionList = directionList.filter(direction => direction != \"none\");\n\n  //Return the filtered list of valid directions\n  return filteredDirectionList;\n}\n\nfunction canChangeDirection(validDirections = []) {\n\n  //Is the sprite in a dead-end (cul de sac.) This will be true if there's only\n  //one element in the `validDirections` array\n  let inCulDeSac = validDirections.length === 1;\n\n  //Is the sprite trapped? This will be true if there are no elements in\n  //the `validDirections` array\n  let trapped = validDirections.length === 0;\n\n  //Is the sprite in a passage? This will be `true` if the the sprite\n  //is at a location that contain the values \n  //“left” or “right” and “up” or “down” \n  let up = validDirections.find(x => x === \"up\"),\n    down = validDirections.find(x => x === \"down\"),\n    left = validDirections.find(x => x === \"left\"),\n    right = validDirections.find(x => x === \"right\"),\n    atIntersection = (up || down) && (left || right);\n\n  //Return `true` if the sprite can change direction or\n  //`false` if it can't\n  return trapped || atIntersection || inCulDeSac;\n}\n\nfunction randomDirection(sprite, validDirections = []) {\n\n  //The `randomInt` helper function returns a random integer between a minimum\n  //and maximum value\n  let randomInt = (min, max) => {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  };\n\n  //Is the sprite trapped? \n  let trapped = validDirections.length === 0;\n\n  //If the sprite isn't trapped, randomly choose one of the valid\n  //directions. Otherwise, return the string \"trapped\"\n  if (!trapped) {\n    return validDirections[randomInt(0, validDirections.length - 1)];\n  } else {\n    return \"trapped\"\n  }\n}\n\nfunction closestDirection(spriteOne, spriteTwo, validDirections = []) {\n\n  //A helper function to find the closest direction\n  let closest = () => {\n\n    //Plot a vector between spriteTwo and spriteOne\n    let vx = spriteTwo.centerX - spriteOne.centerX,\n      vy = spriteTwo.centerY - spriteOne.centerY;\n\n    //If the distance is greater on the X axis...\n    if (Math.abs(vx) >= Math.abs(vy)) {\n\n      //Try left and right\n      if (vx <= 0) {\n        return \"left\";\n      } else {\n        return \"right\";\n      }\n    }\n\n    //If the distance is greater on the Y axis...\n    else {\n\n      //Try up and down\n      if (vy <= 0) {\n        return \"up\"\n      } else {\n        return \"down\"\n      }\n    }\n  };\n\n  //The closest direction that's also a valid direction\n  let closestValidDirection = validDirections.find(x => x === closest());\n\n  //The `randomInt` helper function returns a random integer between a minimum\n  //and maximum value\n  let randomInt = (min, max) => {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  };\n\n  //Is the sprite trapped? \n  let trapped = validDirections.length === 0;\n\n  //If the sprite isn't trapped, choose the closest direction\n  //from the `validDirections` array. If there's no closest valid\n  //direction, then choose a valid direction at random.\n  if (!trapped) {\n    if (closestValidDirection) {\n      return closestValidDirection;\n    } else {\n      return validDirections[randomInt(0, validDirections.length - 1)];\n    }\n  } else {\n    return \"trapped\"\n  }\n}\n\nfunction tileBasedLineOfSight(\n  spriteOne, //The first sprite, with `centerX` and `centerY` properties\n  spriteTwo, //The second sprite, with `centerX` and `centerY` properties\n  mapArray, //The tile map array\n  world, //The `world` object that contains the `tilewidth\n  //`tileheight` and `widthInTiles` properties\n  emptyGid = 0, //The Gid that represents and empty tile, usually `0`\n  segment = 32, //The distance between collision points\n  angles = [] //An array of angles to which you want to \n  //restrict the line of sight\n) {\n\n  //Plot a vector between spriteTwo and spriteOne\n  let vx = spriteTwo.centerX - spriteOne.centerX,\n    vy = spriteTwo.centerY - spriteOne.centerY;\n\n  //Find the vector's magnitude (its length in pixels)\n  let magnitude = Math.sqrt(vx * vx + vy * vy);\n\n  //How many points will we need to test?\n  let numberOfPoints = magnitude / segment;\n\n  //Create an array of x/y points that\n  //extends from `spriteOne` to `spriteTwo`  \n  let points = () => {\n\n    //Initialize an array that is going to store all our points\n    //along the vector\n    let arrayOfPoints = [];\n\n    //Create a point object for each segment of the vector and \n    //store its x/y position as well as its index number on\n    //the map array \n    for (let i = 1; i <= numberOfPoints; i++) {\n\n      //Calculate the new magnitude for this iteration of the loop\n      let newMagnitude = segment * i;\n\n      //Find the unit vector\n      let dx = vx / magnitude,\n        dy = vy / magnitude;\n\n      //Use the unit vector and newMagnitude to figure out the x/y\n      //position of the next point in this loop iteration\n      let x = spriteOne.centerX + dx * newMagnitude,\n        y = spriteOne.centerY + dy * newMagnitude;\n\n\n      //The getIndex function converts x/y coordinates into\n      //map array index positon numbers\n      let getIndex = (x, y, tilewidth, tileheight, mapWidthInTiles) => {\n\n        //Convert pixel coordinates to map index coordinates\n        let index = {};\n        index.x = Math.floor(x / tilewidth);\n        index.y = Math.floor(y / tileheight);\n\n        //Return the index number\n        return index.x + (index.y * mapWidthInTiles);\n      };\n\n      //Find the map index number that this x and y point corresponds to\n      let index = getIndex(\n        x, y,\n        world.tilewidth,\n        world.tileheight,\n        world.widthInTiles\n      );\n\n      //Push the point into the `arrayOfPoints`\n      arrayOfPoints.push({\n        x, y, index\n      });\n    }\n\n    //Return the array\n    return arrayOfPoints;\n  };\n\n  //The tile-based collision test.\n  //The `noObstacles` function will return `true` if all the tile\n  //index numbers along the vector are `0`, which means they contain \n  //no walls. If any of them aren't 0, then the function returns\n  //`false` which means there's a wall in the way \n  let noObstacles = points().every(point => {\n    return mapArray[point.index] === emptyGid\n  });\n\n  //Restrict the line of sight to right angles only (we don't want to\n  //use diagonals)\n  let validAngle = () => {\n\n    //Find the angle of the vector between the two sprites\n    let angle = Math.atan2(vy, vx) * 180 / Math.PI;\n\n    //If the angle matches one of the valid angles, return\n    //`true`, otherwise return `false`\n    if (angles.length !== 0) {\n      return angles.some(x => x === angle);\n    } else {\n      return true;\n    }\n  };\n\n  //Return `true` if there are no obstacles and the line of sight\n  //is at a 90 degree angle\n  if (noObstacles === true && validAngle() === true) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n//Geometry based Line of sight\nfunction lineOfSight(\n  spriteOne, //The first sprite, with `centerX` and `centerY` properties\n  spriteTwo, //The second sprite, with `centerX` and `centerY` properties\n  obstacles, //An array of sprites which act as obstacles\n  segment = 32 //The distance between collision points\n) {\n\n  //Plot a vector between spriteTwo and spriteOne\n  let vx = spriteTwo.centerX - spriteOne.centerX,\n    vy = spriteTwo.centerY - spriteOne.centerY;\n\n  //Find the vector's magnitude (its length in pixels)\n  let magnitude = Math.sqrt(vx * vx + vy * vy);\n\n  //How many points will we need to test?\n  let numberOfPoints = magnitude / segment;\n\n  //Create an array of x/y points, separated by 64 pixels, that\n  //extends from `spriteOne` to `spriteTwo`  \n  let points = () => {\n\n    //Initialize an array that is going to store all our points\n    //along the vector\n    let arrayOfPoints = [];\n\n    //Create a point object for each segment of the vector and \n    //store its x/y position as well as its index number on\n    //the map array \n    for (let i = 1; i <= numberOfPoints; i++) {\n\n      //Calculate the new magnitude for this iteration of the loop\n      let newMagnitude = segment * i;\n\n      //Find the unit vector. This is a small, scaled down version of\n      //the vector between the sprites that's less than one pixel long.\n      //It points in the same direction as the main vector, but because it's\n      //the smallest size that the vector can be, we can use it to create\n      //new vectors of varying length\n      let dx = vx / magnitude,\n        dy = vy / magnitude;\n\n      //Use the unit vector and newMagnitude to figure out the x/y\n      //position of the next point in this loop iteration\n      let x = spriteOne.centerX + dx * newMagnitude,\n        y = spriteOne.centerY + dy * newMagnitude;\n\n      //Push a point object with x and y properties into the `arrayOfPoints`\n      arrayOfPoints.push({\n        x, y\n      });\n    }\n\n    //Return the array of point objects\n    return arrayOfPoints;\n  };\n\n  //Test for a collision between a point and a sprite\n  let hitTestPoint = (point, sprite) => {\n\n    //Find out if the point's position is inside the area defined\n    //by the sprite's left, right, top and bottom sides\n    let left = point.x > sprite.x,\n      right = point.x < (sprite.x + sprite.width),\n      top = point.y > sprite.y,\n      bottom = point.y < (sprite.y + sprite.height);\n\n    //If all the collision conditions are met, you know the\n    //point is intersecting the sprite\n    return left && right && top && bottom;\n  };\n\n  //The `noObstacles` function will return `true` if all the tile\n  //index numbers along the vector are `0`, which means they contain \n  //no obstacles. If any of them aren't 0, then the function returns\n  //`false` which means there's an obstacle in the way \n  let noObstacles = points().every(point => {\n    return obstacles.every(obstacle => {\n      return !(hitTestPoint(point, obstacle))\n    });\n  });\n\n  //Return the true/false value of the collision test\n  return noObstacles;\n}"]}