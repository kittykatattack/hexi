{"version":3,"sources":["../src/closestDirection.js"],"names":[],"mappings":"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","file":"closestDirection.js","sourcesContent":["let thingsToLoad = [\n  \"images/monsterMaze.png\",\n  \"maps/monsterMaze.json\"\n];\n\n//Create a new Hexi instance, and start it.\nlet g = hexi(704, 512, setup, thingsToLoad);\n\n//Set the background color and scale the canvas\n//g.backgroundColor = \"black\";\ng.scaleToWindow();\n\n//Start Hexi\ng.start();\n\n//Game variables\nlet world, alien, message, wallMapArray,\n  bombMapArray, bombSprites, bombLayer, monsterFrames, monsters,\n  leftArrow, upArrow, downArrow, rightArrow;\n\n//The `setup` function to initialize your application\nfunction setup() {\n\n  //Make the world from the Tiled JSON data and the tileset PNG image\n  world = g.makeTiledWorld(\n    \"maps/monsterMaze.json\",\n    \"images/monsterMaze.png\"\n  );\n\n  //Create the alien sprite and set its speed\n  alien = world.getObject(\"alien\");\n  alien.speed = 4\n\n  //Get a reference to the array that stores all the wall data\n  wallMapArray = world.getObject(\"wallLayer\").data;\n\n  //We're just using the monsters sprites in the Tiled Editor\n  //map as generic placeholders.  We're going to use their size and\n  //position data to build new monster sprites from scratch and place\n  //them in the world. That's because we want to give the monsters\n  //custom animation frames. Here's how to do this:\n\n  //1. Get a reference to the map's monster sprites and the \n  //layer container that those sprites are one\n  let mapMonsters = world.getObjects(\"monster\");\n  let monsterLayer = world.getObject(\"monsterLayer\");\n\n  //2.Define the monster's animation frames. In this example there are just\n  //two: the monster mouth open, and the monster's mouth closed.\n  monsterFrames = g.frames(\n    \"images/monsterMaze.png\", //The tileset image\n    [\n      [128, 0],\n      [128, 64]\n    ], //The `x` and `y` positions of frames\n    64, 64 //The `width` and `height` of each frame\n  );\n\n  //3.Create a new array called `monsters` that contains a new `monster`\n  //sprite for each `mapMonster` in the original array. The new\n  //`monster` sprites are created using the `monsterFrames` we defined\n  //above and have the same `x` and `y` positions as the original\n  //placeholder monsters from the Tiled Editor map. We're also going\n  //to give them new `direction` and `speed`. Finally, we need to make the \n  //placeholder monsters invisible and add the new `monster` sprite\n  //to the `monsterLayer` container. \n  monsters = mapMonsters.map(mapMonster => {\n    let monster = g.sprite(monsterFrames);\n    monster.x = mapMonster.x;\n    monster.y = mapMonster.y;\n    monster.direction = \"none\";\n    monster.speed = 4;\n    monsterLayer.addChild(monster);\n    mapMonster.visible = false;\n\n    //Define the monster's two states: `normal` and `scared`\n    //`0` and `1` refer to the monster's two animation frames\n    monster.states = {\n      normal: 0,\n      scared: 1\n    };\n    return monster;\n  });\n\n  //Give the `alien` a `direction` property and initilize it to \"none\"\n  alien.direction = \"none\";\n\n  //Configure Hexi's built in arrow keys to assign the alien a direction\n  //Create some keyboard objects\n  leftArrow = g.keyboard(37);\n  upArrow = g.keyboard(38);\n  rightArrow = g.keyboard(39);\n  downArrow = g.keyboard(40);\n\n  //Program the keyboard objects\n  leftArrow.press = () => alien.direction = \"left\";\n  upArrow.press = () => alien.direction = \"up\";\n  rightArrow.press = () => alien.direction = \"right\";\n  downArrow.press = () => alien.direction = \"down\";\n\n  //Change the game state to `play`\n  g.state = play;\n}\n\n//The `play` function contains all the game logic and runs in a loop\nfunction play() {\n\n  //Change the alien's direction if it's directly centered\n  //over a tile cell\n\n  if (isCenteredOverCell(alien)) {\n    let velocity = directionToVelocity(alien.direction, alien.speed);\n    alien.vx = velocity.vx;\n    alien.vy = velocity.vy;\n  }\n\n  //Move the alien\n  g.move(alien);\n\n  //Check for a collision between the alien and the floor\n  let alienVsFloor = g.hitTestTile(alien, wallMapArray, 0, world, \"every\");\n\n  //If every corner point on the alien isn't touching a floor \n  //tile (array gridIDNumber: 0) then prevent the alien from moving\n  if (!alienVsFloor.hit) {\n\n    //To prevent the alien from moving, subtract its velocity from its position\n    alien.x -= alien.vx;\n    alien.y -= alien.vy;\n    alien.vx = 0;\n    alien.vy = 0;\n  }\n\n  monsters.forEach(monster => {\n\n    //1. Is the monster directly centered over a map tile cell?\n    if (isCenteredOverCell(monster)) {\n\n      //2. Yes, it is, so find out which are valid directions to move.\n      //`findValidDirections` returns an array which can include any\n      //of these string values: \"up\", \"right\", \"down\", \"left\" or \"none\"\n      monster.validDirections = validDirections(\n        monster, wallMapArray, 0, world\n      );\n\n      //3. Can the monster change its direction? \n      if (canChangeDirection(monster.validDirections)) {\n\n        //4. If it can, randomly select a new direction\n        monster.direction = closestDirection(monster, alien, monster.validDirections);\n      }\n\n      //5. Use the monster's direction and speed to find its \n      //new velocity\n      let velocity = directionToVelocity(monster.direction, monster.speed);\n      monster.vx = velocity.vx;\n      monster.vy = velocity.vy;\n    }\n\n    //6. Move the monster\n    monster.x += monster.vx;\n    monster.y += monster.vy;\n\n    //Change the monster's state\n\n    //1. Plot a vector between the monster and the alien\n    var vx = alien.centerX - monster.centerX,\n      vy = alien.centerY - monster.centerY;\n\n    //2. Find the vector's magnitude. This tells you how far \n    //apart the sprites are\n    var magnitude = Math.sqrt(vx * vx + vy * vy);\n\n    //3. If the monster is less than 192 pixels away from the alien,\n    //change the monster's state to `scared`. Otherwise, set its\n    //state to `normal`\n    if (magnitude < 192) {\n      monster.show(monster.states.scared)\n    } else {\n      monster.show(monster.states.normal)\n    }\n  });\n}\n\n//Helper functions\n\n//`isCenteredOverCell` returns true or false depending on whether a \n//sprite is exactly aligned to anintersection in the maze corridors\nfunction isCenteredOverCell(sprite) {\n  return Math.floor(sprite.x) % world.tilewidth === 0 && Math.floor(sprite.y) % world.tileheight === 0\n}\n\n//Convert the direction string to an object with `vx` and `vy`\n//velocity properties\nfunction directionToVelocity(direction = \"\", speed = 0) {\n  switch (direction) {\n    case \"up\":\n      return {\n        vy: -speed,\n        vx: 0\n      }\n      break;\n    case \"down\":\n      return {\n        vy: speed,\n        vx: 0\n      };\n      break;\n    case \"left\":\n      return {\n        vx: -speed,\n        vy: 0\n      };\n      break;\n    case \"right\":\n      return {\n        vx: speed,\n        vy: 0\n      };\n      break;\n    default:\n      return {\n        vx: 0,\n        vy: 0\n      };\n  }\n};\n\n//Change the sprite's velocity if it's centered \n//over a tile grid cell \nfunction changeDirection(sprite, direction, speed) {\n  switch (direction) {\n    case \"up\":\n      sprite.vy = -speed;\n      sprite.vx = 0;\n      break;\n    case \"down\":\n      sprite.vy = speed;\n      sprite.vx = 0;\n      break;\n    case \"left\":\n      sprite.vx = -speed;\n      sprite.vy = 0;\n      break;\n    case \"right\":\n      sprite.vx = speed;\n      sprite.vy = 0;\n      break;\n    default:\n      sprite.vx = 0;\n      sprite.vy = 0;\n      break;\n  }\n};\n\nfunction surroundingCrossCells(index, widthInTiles) {\n  return [\n    index - widthInTiles,\n    index - 1,\n    index + 1,\n    index + widthInTiles,\n  ];\n}\n\nfunction surroundingDiagonalCells(index, widthInTiles) {\n  return [\n    index - widthInTiles - 1,\n    index - widthInTiles + 1,\n    index + widthInTiles - 1,\n    index + widthInTiles + 1,\n  ];\n}\n\nfunction validDirections(sprite, mapArray, validGid, world) {\n\n  //Get the sprite's current map index position number\n  let index = g.getIndex(\n    sprite.x,\n    sprite.y,\n    world.tilewidth,\n    world.tileheight,\n    world.widthInTiles\n  );\n\n  //An array containing the index numbers of tile cells\n  //above, below and to the left and right of the sprite\n  let surroundingCrossCells = (index, widthInTiles) => {\n    return [\n      index - widthInTiles,\n      index - 1,\n      index + 1,\n      index + widthInTiles,\n    ];\n  };\n\n  //Get the index position numbers of the 4 cells to the top, right, left\n  //and bottom of the sprite\n  let surroundingIndexNumbers = surroundingCrossCells(index, world.widthInTiles);\n\n  //Find all the tile gid numbers that match the surrounding index numbers\n  let surroundingTileGids = surroundingIndexNumbers.map(index => mapArray[index]);\n\n  //`directionList` is an array of 4 string values that can be either\n  //\"up\", \"left\", \"right\", \"down\" or \"none\", depending on \n  //whether there is a cell with a valid gid that matches that direction.\n  let directionList = surroundingTileGids.map((gid, i) => {\n\n    //The possible directions\n    let possibleDirections = [\"up\", \"left\", \"right\", \"down\"];\n\n    //If the direction is valid, choose the matching string \n    //identifier for that direction. Otherwise, return \"none\"\n    if (gid === validGid) {\n      return possibleDirections[i];\n    } else {\n      return \"none\";\n    }\n  });\n\n  //We don't need \"none\" in the list of directions \n  //(it's just a placeholder), so let's filter it out\n  let filteredDirectionList = directionList.filter(direction => direction != \"none\");\n\n  //Return the filtered list of valid directions\n  return filteredDirectionList;\n}\n\nfunction canChangeDirection(validDirections = []) {\n\n  //Is the sprite in a dead-end (cul de sac.) This will be true if there's only\n  //one element in the `validDirections` array\n  let inCulDeSac = validDirections.length === 1;\n\n  //Is the sprite trapped? This will be true if there are no elements in\n  //the `validDirections` array\n  let trapped = validDirections.length === 0;\n\n  //Is the sprite in a passage? This will be `true` if the the sprite\n  //is at a location that contain the values \n  //“left” or “right” and “up” or “down” \n  let up = validDirections.find(x => x === \"up\"),\n    down = validDirections.find(x => x === \"down\"),\n    left = validDirections.find(x => x === \"left\"),\n    right = validDirections.find(x => x === \"right\"),\n    atIntersection = (up || down) && (left || right);\n\n  //Return `true` if the sprite can change direction or\n  //`false` if it can't\n  return trapped || atIntersection || inCulDeSac;\n}\n\nfunction closestDirection(spriteOne, spriteTwo, validDirections = []) {\n\n  //Find the closest direction\n  let closest = () => {\n\n    //Plot a vector between spriteTwo and spriteOne\n    let vx = spriteTwo.centerX - spriteOne.centerX,\n      vy = spriteTwo.centerY - spriteOne.centerY;\n\n    //If the distance is greater on the X axis...\n    if (Math.abs(vx) >= Math.abs(vy)) {\n\n      //Try left and right\n      if (vx <= 0) {\n        return \"left\";\n      } else {\n        return \"right\";\n      }\n    }\n    //If the distance is greater on the Y axis...\n    else {\n\n      //Try up and down\n      if (vy <= 0) {\n        return \"up\"\n      } else {\n        return \"down\"\n      }\n    }\n  };\n\n  //The closest direction that's also a valid direction\n  let closestValidDirection = validDirections.find(x => x === closest());\n\n  //The `randomInt` helper function returns a random integer between a minimum\n  //and maximum value\n  let randomInt = (min, max) => {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  };\n\n  //Is the sprite trapped? \n  let trapped = validDirections.length === 0;\n\n  //If the sprite isn't trapped, choose the closest direction\n  //from the `validDirections` array. If there's no closest valid\n  //direction, then choose a valid direction at random.\n  if (!trapped) {\n    if (closestValidDirection) {\n      return closestValidDirection;\n    } else {\n      return validDirections[randomInt(0, validDirections.length - 1)];\n    }\n  } else {\n    return \"trapped\"\n  }\n}\n\n/*\n//`isAtIntersection` returns true or false depending on whether a \n//sprite is exactly aligned to anintersection in the maze corridors\nfunction isCenteredOverCell(sprite) {\n  let trueOrFalse =\n    Math.floor(sprite.x) % world.tilewidth === 0 && Math.floor(sprite.y) % world.tileheight === 0\n  return trueOrFalse;\n}\n\nfunction directionToVelocity(direction = \"none\", speed = 0) {\n\n  //Change the sprite's velocity if it's centered \n  //over a tile grid cell \n  switch (direction) {\n    case \"up\":\n      return {\n        vy: -speed,\n        vx: 0\n      }\n      break;\n    case \"down\":\n      return {\n        vy: speed,\n        vx: 0\n      };\n      break;\n    case \"left\":\n      return {\n        vx: -speed,\n        vy: 0\n      };\n      break;\n    case \"right\":\n      return {\n        vx: speed,\n        vy: 0\n      };\n      break;\n    case \"none\":\n      return {\n        vx: 0,\n        vy: 0\n      };\n  }\n};\n\nfunction changeDirection(sprite, direction, speed) {\n\n  //Change the sprite's velocity if it's centered \n  //over a tile grid cell \n  switch (direction) {\n    case \"up\":\n      sprite.vy = -speed;\n      sprite.vx = 0;\n      break;\n    case \"down\":\n      sprite.vy = speed;\n      sprite.vx = 0;\n      break;\n    case \"left\":\n      sprite.vx = -speed;\n      sprite.vy = 0;\n      break;\n    case \"right\":\n      sprite.vx = speed;\n      sprite.vy = 0;\n      break;\n    case \"none\":\n      sprite.vx = 0;\n      sprite.vy = 0;\n      break;\n  }\n};\n\nfunction surroundingCrossCells(index, widthInTiles) {\n  return [\n    index - widthInTiles,\n    index - 1,\n    index + 1,\n    index + widthInTiles,\n  ];\n}\n\nfunction surroundingDiagonalCells(index, widthInTiles) {\n  return [\n    index - widthInTiles - 1,\n    index - widthInTiles + 1,\n    index + widthInTiles - 1,\n    index + widthInTiles + 1,\n  ];\n}\n\nfunction findValidDirections(sprite, mapArray, validGid, world) {\n\n  //Get the sprite's current map index position number\n  let index = g.getIndex(\n    sprite.x,\n    sprite.y,\n    world.tilewidth,\n    world.tileheight,\n    world.widthInTiles\n  );\n\n  //Get the index position numbers of the 4 cells to the top, right, left\n  //and bottom of the sprite\n  let surroundingIndexNumbers = surroundingCrossCells(index, world.widthInTiles);\n\n  //Find all the tiles that match the surrounding index numbers\n  let surroundingTiles = surroundingIndexNumbers.map(indexNumber => {\n    return g.getTile(indexNumber, mapArray, world);\n  });\n\n  //Floor tiles have a gid value of 0, and are a valid tiles for the sprite\n  //to travel on. 0 is the `validGid` value in this example. \n  //`validTiles` is an array of true/false values where each\n  //valid direction tile (a floor tile) will be represented as `true`\n  let validTiles = surroundingTiles.map(tile => {\n    return tile.gid === validGid;\n  });\n\n  //`directionList` is an array of 4 string values that can be either\n  //\"up\", \"left\", \"right\", \"down\" or \"none\", depending on \n  //whether there is a `validTile` that matches that direction.\n  let directionList = validTiles.map((validTile, i) => {\n\n    //The possible directions\n    let possibleDirections = [\"up\", \"left\", \"right\", \"down\"];\n\n    //If the direction is valid, choose the matching string \n    //identifier for that direction. Otherwise, return \"none\"\n    if (validTile) {\n      return possibleDirections[i];\n    } else {\n      return \"none\";\n    }\n  });\n\n  //We don't need \"none\" in the list of directions, so \n  //let's filter it out\n  let filteredDirectionList = directionList.filter(direction => direction != \"none\");\n\n  //Return the filtered list of valid directions\n  return filteredDirectionList;\n}\n\nfunction findClosestDirection(spriteOne, spriteOneDirection, spriteTwo, mapArray, world) {\n\n  //Get the sprite's list of valid directions and the values it needs\n  //to understand the kind of map environment that it's in\n  let validDirections = findValidDirections(spriteOne, mapArray, 0, world);\n  let inUpOrDownPassage = validDirections.indexOf(\"up\") !== -1 || validDirections.indexOf(\"down\") !== -1;\n  let inLeftOrRightPassage = validDirections.indexOf(\"left\") !== -1 || validDirections.indexOf(\"right\") !== -1;\n  let inCulDeSac = validDirections.length === 1;\n  let trapped = validDirections.length === 0;\n\n  //Randomly select one of the valid directions\n  let randomDirection = () => {\n    if (!trapped) {\n      return validDirections[g.randomInt(0, validDirections.length - 1)];\n    } else {\n      return \"none\"\n    }\n  };\n\n  //Find the closest direction\n  let closestDirection = () => {\n\n    //Plot a vector between spriteTwo and spriteOne\n    let vx = spriteTwo.centerX - spriteOne.centerX,\n      vy = spriteTwo.centerY - spriteOne.centerY;\n\n    //If the distance is greater on the X axis...\n    if (Math.abs(vx) >= Math.abs(vy)) {\n\n      //Try left and right\n      if (vx <= 0) {\n        return \"left\";\n      } else {\n        return \"right\";\n      }\n    }\n    //If the distance is greater on the Y axis...\n    else {\n      //Try up and down\n      if (vy <= 0) {\n        return \"up\"\n      } else {\n        return \"down\"\n      }\n    }\n  };\n\n  //Return `true` if the closest direction is also a valid direction\n  let closestDirectionIsValid = validDirections.indexOf(closestDirection()) !== -1;\n\n  //Check to make sure the sprite is at a location on the map where\n  //it can change its direction.\n  //Return the `closestDirection` if it's also a valid direction,\n  //otherwise choose a new random directon.\n  //If the sprite is not at a location where it can change its direction,\n  //just return the same direction that it had before\n  if (!trapped) {\n    if (inLeftOrRightPassage && inUpOrDownPassage || inCulDeSac) {\n      if (closestDirectionIsValid) {\n        return closestDirection();\n      } else {\n        return randomDirection();\n      }\n    } else {\n      return spriteOneDirection;\n    }\n  } else {\n    return spriteOneDirection;\n  }\n}\n*/"]}