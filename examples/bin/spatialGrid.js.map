{"version":3,"sources":["../src/spatialGrid.js"],"names":[],"mappings":"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","file":"spatialGrid.js","sourcesContent":["/*\nA marble game prototyple illustrating collisions between moving circles\n*/\n\n//Create a new Hexi instance, and start it.\nlet g = hexi(512, 512, setup, [\"images/marbles.png\"]);\n\n//Set the background color and scale the canvas\ng.backgroundColor = \"black\";\ng.scaleToWindow();\n\n//Declare variables used in more than one function\nlet sling, marbles, capturedMarble;;\n\n//If you're not loading any files, start Hexi after\n//you've declared your global variables\ng.start();\n\n//The `setup` function to initialize your application\nfunction setup() {\n\n  /*\n  Create the grid of marbles using the `grid` function. `grid` returns a\n  `group` sprite object that contains a sprite for every cell in the\n  grid. You can define the rows and columns in the grid, whether or\n  not the sprites should be centered inside each cell, or what their offset from the\n  top left corner of each cell should be. Supply a function that\n  returns the sprite that you want to make for each cell. You can\n  supply an optional final function that runs any extra code after\n  each sprite has been created. Here's the format for creating a grid:\n\n      gridGroup = grid(\n\n        //Set the grid's properties\n        columns, rows, cellWidth, cellHeight, \n        areSpirtesCentered?, xOffset, yOffset,\n\n        //A function that returns a sprite\n        () => {return g.circle(16, \"blue\"),\n\n        //An optional final function that runs some extra code\n        () => {console.log(\"extra!\")\n      );\n  */\n  marbles = g.grid(\n\n    //Set the grid's properties\n    5, 5, 128, 128,\n    true, 0, 0,\n\n    //A function that describes how to make each marble in the grid\n    () => {\n      let frames = g.filmstrip(\"images/marbles.png\", 32, 32);\n      let marble = g.sprite(frames);\n      marble.show(g.randomInt(0, 5));\n      marble.circular = true;\n      let sizes = [8, 12, 16, 20, 24, 28, 32];\n      marble.diameter = sizes[g.randomInt(0, 6)];\n      marble.vx = g.randomInt(-10, 10);\n      marble.vy = g.randomInt(-10, 10);\n      marble.frictionX = 0.99;\n      marble.frictionY = 0.99;\n      marble.mass = 0.75 + (marble.diameter / 32);\n      return marble;\n    },\n\n    //Run any extra code after each peg is made, if you want to\n    () => console.log(\"extra!\")\n  );\n\n  //Create the \"sling\" which is a line that will connect\n  //the pointer to the marbles\n  sling = g.line(\"Yellow\", 4);\n  sling.visible = false;\n\n  //A variable to store the captured marble\n  capturedMarble = null;\n\n  //Change the state to `play`\n  g.state = play;\n}\n\n//The `play` function will run in a loop\nfunction play() {\n\n  //If a marble has been captured, draw the \n  //sling (the yellow line) between the pointer and\n  //the center of the captured marble\n  if (capturedMarble !== null) {\n    sling.visible = true;\n    sling.ax = capturedMarble.centerX;\n    sling.ay = capturedMarble.centerY;\n    sling.bx = g.pointer.x;\n    sling.by = g.pointer.y;\n  }\n\n  //Shoot the marble if the pointer has been released \n  if (g.pointer.isUp) {\n    sling.visible = false;\n    if (capturedMarble !== null) {\n\n      //Find out how long the sling is\n      sling.length = g.distance(capturedMarble, g.pointer);\n\n      //Get the angle between the center of the marble and the pointer\n      sling.angle = g.angle(g.pointer, capturedMarble);\n\n      //Shoot the marble away from the pointer with a velocity\n      //proportional to the sling's length\n      capturedMarble.vx = Math.cos(sling.angle) * sling.length / 5;\n      capturedMarble.vy = Math.sin(sling.angle) * sling.length / 5;\n\n      //Release the captured marble\n      capturedMarble = null;\n    }\n  }\n\n\n  marbles.children.forEach(marble => {\n\n    //Check for a collision with the pointer and marble\n    if (g.pointer.isDown && capturedMarble === null) {\n      if (g.hit(g.pointer, marble)) {\n\n        //If there's a collision, capture the marble\n        capturedMarble = marble;\n        capturedMarble.vx = 0;\n        capturedMarble.vy = 0;\n      }\n    }\n\n    //Apply friction\n    marble.vx *= marble.frictionX;\n    marble.vy *= marble.frictionY;\n\n    //Move the marble by applying the new calculated velocity\n    //to the marble's x and y position\n    g.move(marble);\n\n    //Contain the marble inside the stage and make it bounce\n    //off the edges\n    g.contain(marble, g.stage, true);\n  });\n\n  //Add the marbles to the spatial grid\n  marbles.children.forEach(marble => {\n    getIndex(marble)\n\n  });\n\n  //1. Create the spatial grid\n\n  //A function to initialize the spatial grid\n  let spatialGrid = (widthInPixels, heightInPixels, cellSizeInPixels, spritesArray) => {\n\n    //Find out how many cells we need and how long the\n    //grid array should be\n    let width = widthInPixels / cellSizeInPixels,\n      height = heightInPixels / cellSizeInPixels,\n      length = width * height;\n\n    //Initialize an empty grid\n    let gridArray = [];\n\n    //Add empty sub-arrays to element \n    for (let i = 0; i < length; i++) {\n\n      //Add empty arrays to each element. This is where\n      //we're going to store sprite references\n      gridArray.push([]);\n    }\n\n    //Add the sprites to the grid\n    spritesArray.forEach(sprite => {\n\n      //Find out the sprite's current map index position\n      let index = getIndex(sprite.x, sprite.y, cellSizeInPixels, cellSizeInPixels, width);\n\n      //Add the sprite to the array at that index position\n      gridArray[index].push(sprite);\n\n    });\n\n    return gridArray;\n  };\n\n  //Create the spatial grid and add the marble sprites to it\n  let grid = spatialGrid(512, 512, 64, marbles.children);\n\n  //2. Check for collisions between sprites in the grid\n\n  //Loop through all the sprites\n  for (let i = 0; i < marbles.children.length; i++) {\n\n    //Get a reference to the current sprite in the loop\n    let sprite = marbles.children[i];\n\n    //Find out the sprite's current map index position\n    let gridWidthInTiles = 512 / 64;\n    let index = getIndex(sprite.x, sprite.y, 64, 64, gridWidthInTiles);\n\n    //Find out what all the surrounding nodes are, including those that\n    //might be beyond the borders of the grid\n    let allSurroundingCells = [\n      grid[index - gridWidthInTiles - 1],\n      grid[index - gridWidthInTiles],\n      grid[index - gridWidthInTiles + 1],\n      grid[index - 1],\n      grid[index],\n      grid[index + 1],\n      grid[index + gridWidthInTiles - 1],\n      grid[index + gridWidthInTiles],\n      grid[index + gridWidthInTiles + 1]\n    ];\n\n    //Find all the sprites that might be colliding with this current sprite\n    for (let j = 0; j < allSurroundingCells.length; j++) {\n\n      //Get a reference to the current surrounding cell\n      let cell = allSurroundingCells[j]\n\n      //If the cell isn't `undefined` (beyond the grid borders) \n      //and it's not empty, check for a collision between \n      //the current sprite and sprites in the cell\n      if (cell && cell.length !== 0) {\n\n        //Loop through all the sprites in the cell\n        for (let k = 0; k < cell.length; k++) {\n\n          //Get a reference to the current sprite being checked\n          //in the cell\n          let surroundingSprite = cell[k];\n\n          //If the sprite in the cell is not the same as the current\n          //sprite in the main loop, then check for a collision\n          //between those sprites\n          if (surroundingSprite !== sprite) {\n\n            //Perform a narrow-phase collision check to bounce\n            //the sprites apart\n            g.movingCircleCollision(sprite, surroundingSprite);\n          }\n        }\n      }\n    }\n\n    //Finally, remove this current sprite from the current \n    //spatial grid cell because all possible collisions \n    //involving this sprite have been checked\n    grid[index] = grid[index].filter(x => x !== sprite);\n  }\n}\n\n//The `getIndex` helper function\n//converts a sprite's x and y position to an array index number.\n//It returns a single index value that tells you the map array\n//index number that the sprite is in\nfunction getIndex(x, y, tilewidth, tileheight, mapWidthInTiles) {\n  let index = {};\n\n  //Convert pixel coordinates to map index coordinates\n  index.x = Math.floor(x / tilewidth);\n  index.y = Math.floor(y / tileheight);\n\n  //Return the index number\n  return index.x + (index.y * mapWidthInTiles);\n}"]}